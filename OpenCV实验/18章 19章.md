2020-9-25

学习openCV 3

# 第18章 相机模型与标定

## 射影几何基础

### 射影变换：

将物理世界中坐标为 (Xi, Yi, Zi) 的一系列**物理点Qi** 映射到**投影平面**上坐标为 (xi, yi) 的点的过程。

### 齐次坐标：

是：给定欧氏平面上的一点(*x*,*y*)，对任意非零实数 Z，三元组(*xZ*,*yZ*,*Z*)即称之为该点的齐次坐标。依据定义，将齐次坐标内的数值乘上同一个非零实数，可得到同一点的另一组齐次坐标。例如，笛卡儿坐标上的点 (1,2) 在齐次坐标中即可标示成 (1,2,1) 或 (2,4,2)。原来的笛卡儿坐标可透过将前两个数值除以第三个数值取回。因此，与笛卡儿坐标不同，一个点可以有无限多个齐次坐标表示法。

齐次坐标把**维数为n**的**投影空间**上的点用(n + 1) 维向量表示 (例如x, y, z 变为x, y, z, w) ，其额外限制是任意两个点的值成比例时即为等价点。

这里，图像平面是一个二维投影空间，因此可以利用一个三维向量 q=(q1,q2,q3) 来表示该平面上的点。由于所有点在投影空间中的比例值相同，因此我们可以通过除以q3得到实际的像素坐标值。

### 相机的内参矩阵：

相机成像装置的中心不在光轴上，因此引入两个新参数$c_x,c_y$，对投影屏幕坐标中心可能的偏移(相对光轴)进行建模。

单个像素在低价成像装置上是矩形而不是正方形，焦距fx实际上是透镜的物理焦距长度与成像装置每个单元尺寸sx的乘积（这样做的意义在于sx的单位是像素/每毫米，而f 的单位是毫米，这意味着fx 的单位是像素)。同样的道理也适用于fy和sy 。请记住，sx和sy以及物理焦距f 均不能在相机标定过程
中直接测量，只有组合量 fx=f \*sx和 fy= f\*sy可以直接计算出来而不必拆除相机去直接测量其部件。

将定义相机的参数(如fx, fy, cx和cy ) 重新排列为一个3 x 3 的矩阵；将物理世界中的点投影到相机上，可用下列简单的形式表示：

$ \vec{q} = M \cdot \vec{Q}$
$$
\vec{q}= \begin{bmatrix}x\\y\\w \end{bmatrix}\\
M=\begin {bmatrix} f_x & 0 & c_x \\ 0 & f_y & c_y \\ 0 & 0 & 1 \end{bmatrix} \\
\vec{Q}=\begin{bmatrix}X\\Y\\W \end{bmatrix}\\
$$
将乘数提取出来，可以发现 w=Z，并且是用齐次坐标表示的，可除以w 得到实际像素坐标值

### cv::convertPointsToHomogeneous() 

功能：转换成齐次坐标

需要一个N维点的向量(用一般形式表示) ，并且从该向量中构造出(N + 1)
维点的向量。所有新构造的向量所添加的维度值设置为1 。结果为:$\vec{dst_1}=(src_{i,0}\; src_{i,1}\;... src_{i,N-1}\; 1)$

### cv::convertPointsFromHomogeneous

### Rodrigues变换

在三维空间操作时，通常使用**3x3矩阵**来表示空间中的旋转。因为将向量乘以该矩阵相当于以某种方式旋转向量。缺点是很难理解3 x 3矩阵表示什么样
的旋转。

### 透镜畸变

#### 径向畸变

由透镜的形状造成：在成像装置边缘附近的像素位置产生显著的畸变

#### 切向畸变

由整个相机的组装过程造成：当透镜不完全与图像平面平行的时候会产生切向畸变

#### 5个畸变参数

k1、k2 和 k3 是使用泰勒级数 矫正径向畸变 引入的 系数
p1、p3 是矫正切向畸变引入的参数

畸变向量：5X1矩阵：
$$
\begin{bmatrix} k_1 \\k_2\\p_1\\p_2\\k_3 \end{bmatrix}
$$

## 标定

OpenCV 提供了计算内参矩阵和畸变向量的算法

### 标定方法：

通过 cv::calibrateCamera() 完成：

把相机对准一个具有很多独立可标识点的已知结构。通过从多个视角观察这个结构，我们可以计算拍摄每个图像时相机的（相对）位置和方向以及相机的内部参数。为了提供多个视角，需要旋转和平移物体。

### 旋转矩阵和平移向量

对相机拍摄的一个特定物体的图像，我们可以用旋转和平移来描述物体相对于相机坐标系统的姿态，使用旋转矩阵R 和平移向量t 将点物体上的点P 和图像平面上的点P 关联起来。

**旋转**：任何维数的旋转都可以描述为 坐标向量 乘上 适当尺寸的方阵：将坐标系统旋转。的角度等同于将目标点绕此坐标原点反方向旋转同样的角度。最终，旋转等同于在一个新的坐标系统中对点的位置引入一个新的描述。三维旋转可以分解成围绕每个轴的二维旋转，其中旋转轴的度量保持不变。如果依次绕x，y，z轴旋转角度 $\psi$,$\phi$,$\theta$, 总的旋转矩阵R是$\R_x(\psi)$、$R_y(\phi)$、$R_z(\theta)$ 的乘积：先绕z轴，再绕y轴，再绕x轴

**矩阵乘法表示二维旋转**：

将点旋转角度$\theta$ (这里绕z轴旋转) 等同于将坐标轴反向旋转$\theta$ ,通过简单的三角函数，我们可以看到旋转如何改变点的坐标。

![image-20200927113310884](C:\Users\MY\AppData\Roaming\Typora\typora-user-images\image-20200927113310884.png)

**平移向量**：是第一个坐标系统的原点到第二个坐标系统的原点的偏移量。因此从以物体为中心的原点的坐标系到以相机中心为原点的坐标系，相应的平移向量为：
$$
\vec{T}=origin_{object}-origin_{camera}
$$
因此可得到一个点在物体（或世界）坐标系中坐标为 $\vec{P_0}$ ，对应相机坐标系中的坐标 $\vec{P_c}$ ：
$$
\vec{P_c} = R \cdot (\vec{P_0}-\vec{T})
$$

### 标定板

棋盘

#### 用cv::findChessboardCorners()找到棋盘角点

这个函数将包含棋盘的单个图像作为参数，该图像必须是8 比特图像。

```c++
bool cv::findChessboardCorners(	//Return true if corners were found
    cv::InputArray	image,		//Input chessboard image,8UC1 or 8UC3
    cv::Size		patternSize,//corners per row,and per column
    cv::OutputArray	corners,	//output array of detected corners
    int				flags	= cv::CALIB_CB_ADAPTIVE_THRESH|cv::CALIB_CB_NORMALIZE_IMAGE
)
```

第二个参数 patternSize表示棋盘的每行和每列有多少角点（例如cv~ :Size(cols ， rows) )。

#### flags实现多个附加滤波步骤

帮助找到棋盘上的角点，可以使用布尔OR 来组合以下任意或所有的参数。

cv::CALIB_CB_ADAPTIVE_THRESH
默认方式：根据平均亮度对图像进行阈值化，如果设置此标志，则会使用自适应阈值法

cv::CALIB_CB_NORMALIZE_IMAGE
如果设置此标志，则在应用阈值化操作之前使用cv::equalizeHist()来归一化图像。

cv::CALB_CB_FILTER_QUADS
一旦图像阙值化，算法就会尝试从棋盘上的黑色方块的透视图中找出四边形。这是一个近似，因为假设四边形的每个边缘的线是直的，当图像中存在径向畸变时，就会不正确。如果设置了这个标志，就会对这些四边形应用各种附加约束，以防出现错误的四边形。

cv::CALB_CV_FAST_CHECK
当出现此标志时，则对图像进行快速扫描，以确保图像中存在角点。如果不存在角点，则直接跳过此图像。如果你确定输入数据是"干净的"并且每幅图像中都有棋盘，则此标志就不需要存在。否则，如果在输入中存在没有棋盘的图像，那么使用该标志将节省大量的时间。

#### 棋盘上的亚像素角点和cv::cornerSubPix()

cv::findChessboardCorners() 使用的内部算怯仅提供角点的近似位置。因此， c v: :cornerSubPix() 由cv::findChessboardCorners() 自动调用，以获得更准确的结果。这在实际中意味着这些位置是相对准确的。但是，如果你希望将它们定位到非常高的精度，则需要在输出上自己调用cv::cornerSubPix() (有效地再次调用它) ，但是需要更严格的终止条件。

#### 使用cv::drawChessboardCorners()绘制棋盘角点

把找到的棋盘角点绘制到图像上（通常是我们第一次计算角点的图像）；这样，我们可以看到投影的角点是否与观察到的角点相匹配。使用这个函数，如果没有找到所有的角点，，则可用的角点将被表示为小的红色圆圈。如果整个图案上的角点都找到，那么角点将被绘制成不同的颜色(每一行都将有自己的颜色) ，并将角点以一定顺序用线连接起来。

```c++
void cv::drawChessboardCorners(
    cv::InptOutput	image,		//Input/output chessboard image,8UC3
    cv::Size		patternSize,//corners per row,and per column
    cv::InputArray	corners,	//corners from findChessboardCorners()
    bool			patternWasFound	//Returned from findChessboardCorners()
);
```

的第一个参数是要绘制的图像。由于角点是用有颜色的圆圈表示的，因此必须为8 位的彩色图像。在大多数情况下，它是你提供给cv: :findChessboardCorners() 的图像的一个副本(但是如果不是三通道图像，则需要转换为三通道图像)。接下来的两个参数patternSize 和corners 与c v : :findChessboardCorners() 中对应的参数一样。最后的参数patternWasFound表示是否整个棋盘图案上的角点都被成功找到，这可以设置为cv::findChessboardCorners() 的返回值。

## 单应性

平面的单应性：从一个平面到另一个平面的投影映射，比如：二维平面上的点到相机的成像器上的映射就是平面单应性。

### cv:: findHomography()

将一些列对应点作为输入，返回最能描述这些对应点的单应性矩阵。我们至少需要四点来求解H，但如果我们有更多点的话，可以提供更多的点（因为我们会使用大于3x3的棋盘）。使用更多的点是很有用的，因为这样可以减小噪音和其他不确定因素的干扰。

```c++
cv::Mat cv::findHomography(
    cv::InputArray	srcPoints,	//Input array source points(2-d)
    cv::InputArray	dstPoints,	//Input array result points(2-d)
    cv::int			method	=0,	//0,cv::RANSAC, cv::LMEDS,etc
    double			ransacReprojecThreshold = cv::noArray()//use only non-zero pts
);
```

输入矩阵srcPoints和dstPoints 分别包含原始平面和目标平面中的点。这些都是二维点，因此它们必须是Nx2 或 Nx1的CV_32FC2 的矩阵，或cv::Point2f 的STL vector 对象（或这些的任意组合）。

method用于决定计算单应性矩阵所使用的算法。如果使用默认值0，则会考虑所有点，计算结果会使重新投影的误差最小。在这种情况下，重新投影的误差是H乘以“原始”点与目标点之间的欧氏距离的平方之和。

## 相机标定

如何使用cv::calibrateCamera() 计算这些值，以及如何使用这些模型来矫正标定后的相机产生图像中的畸变。

### 棋盘角点个数和参数个数

通过标定要求解的参数：9个，包括4个相机内在参数和5个畸变参数



# 第19章 投影与三维视觉

在立体视觉中，通过把从不同摄像机同时获取的两个（或更多）图像中的特征，与其他图像中的相关特征进行匹配，并分析特征之间的偏差，产生深度信息。这种方法侧重于将视差效应（三角部分）作为一种计算距离的方法。

## 投影

完成摄像机标定后，可以将物理世界中的点准确地投影图像中的点。这意味着，一旦给定一个摄像机附近的三维物理坐标系的位置，就可以计算出在外部三维点在成像设备中(即在像素坐标系)出现的位置。这个转换在OpenCV 例程cv::projectPoints() 中进行了实现:

```c++
void cv::projectPoints(
    cv::InputArray	objectPoints,	//3xN/Nx3 Nc=1，1xN/Nx1 Nc=3，or vector<Point3f>
    cv::InputArray	rvec,		//旋转矩阵
    cv::InputArray	tvec,		//翻译矩阵
    cv::InputArray	cameraMatrix,	//3x3相机本征矩阵
    cv::OutputArray	imagePoints,	//2xN/Nx2 Nc=1,1xN/Nx1 Nc=2, or vector<Point2f>
    cv::OutputAray	jacobian = cv::noArray(),//Optional,2Nx(10+nDistCoeff)
    double			aspectRatio = 0	//If nonzero,fix fx/fy at this value
);
```

第一个参数objectPoints，是需要投影的点序列，它可以是任何常见的格式：Nx3，3xN，Nx1或1xN 的cv::Vec3f 对象数组，或者仅是一个单纯的旧STL类型向量，其中包含**点的位置**。将这些带入物体自身坐标系，之后可以得到旋转矢量和平移矢量，将物体坐标系和摄像机坐标系联系起来。如果情况特殊，直接在摄像机坐标系中计算更为简单，那么可以只设置该坐标系中的objectpoints ，并把旋转矢量和平移矢量内的元素设置为0